[Unite Seoul 2020 에서 강연한 최적화 관련 영상](https://www.youtube.com/watch?v=tT9LS53HRx4) <br>
<br>

## 🔔 Draw Call
드로우콜이 강조되는 이유는 대부분의 병목의 원인이 드로우콜에 있기 때문이다.<br> 
-> 즉 드로우 콜의 횟수를 줄여, 최적화하는 과정이 대부분 필요하다는 의미다.<br>
<br>

👉 **드로우 콜이란?**<br>
**간략히 설명하자면 CPU가 GPU에게 렌더링 작업을 수행하도록 명령하는 것.** ⭐<br>
<br>

👉 **더 자세하게?**<br>
한 프레임의 렌더링은 **모든 오브젝트를 순차적으로 그려주면서**<br>
오브젝트를 다 그리면 화면에 보여지게 되는 것이다. (렌더링은 Update가 모두 끝난 후 실행)<br>

오브젝트를 화면에 렌더링하기 전에 **우선 해당 오브젝트가 렌더링 대상에 포함되는지 체크한다.**<br>
현재 프레임 상에서 해당 오브젝트가 카메라의 시야 밖에 있다면 안 그려도 되는 것이므로<br>
렌더링 대상에서 제외한다. **이런 검사 과정을 Culling 이라고 한다.**<br>
**컬링을 거친 오브젝트가 렌더링되려면 CPU로부터 GPU에게 정보가 전달되어야한다.**<br>

이렇게 한 프레임 마다 오브젝트를 하나하나 그릴 때 마다 정보들이 CPU에서 GPU로 전달되고 그려진다.<br>
이 과정을 반복해서 모든 오브젝트들이 다 그려지면 한 프레임이 끝나고 화면에 출력한다.<br>
이때 CPU가 GPU에게 렌더링하라고 명령을 보내는 것을 Draw Call 이라고 한다.<br>

**즉 렌더링을 위한 정보 전달(Render State Changes) + 렌더링 명령(DP Call) 까지가 드로우 콜이다.** ⭐<br>
<br>
<br>

👉 **CPU와 GPU가 어떻게 협업하는가**<br>
**GPU가 Mesh를 렌더링하려면 GPU 메모리에서 데이터를 읽어와야한다.** ⭐<br>
그러려면 그 전에 GPU 메모리에 데이터가 있어야한다는 의미이다.<br>

![드로우콜전송정보](https://user-images.githubusercontent.com/43705434/132845106-9be855bf-aac6-437c-906a-65667c2276cd.PNG)<br>
<br>

(매시 데이터 ,텍스쳐, 쉐이더, 트랜스폼, 블렌딩 셋팅 등등)<br>
**메시 정보 = Geometry**<br>
(**버텍스 쉐이더**를 거치고 나면 이제 버텍스들은 서로 연결되어 형태를 이룰 것인데<br>
그래픽스에서는 이 Mesh의 형태를 Geometry라고 부른다.)<br>
<br>

**그래서 렌더링을 수행하기 전에 데이터 로딩이 이루어지면서 Mesh 정보가 GPU 메모리에 담기는 것이다.** ⭐<br>

CPU가 HDD, SDD, SD 카드 등의 스토리지에서 파일을 읽어들이고<br>
데이터를 파싱하여 CPU 메모리에 데이터를 올린다.<br>
그 후 CPU 메모리의 데이터를 GPU 메모리로 복사하는 과정을 거친다.<br>
(**GPU는 VRAM ⭐ 즉 GPU 전용 메모리를 갖고있으며,
해당 메모리에 렌더링에 필요한 데이터가 있다고 보면 된다.**<br>
보통 모바일기기에서는 CPU와 GPU메모리를 물리적으로 나누지 않는다.<br>
하나의 물리적인 메모리를 논리적으로 나누어 사용)<br>

이렇게 데이터를 메모리에 전달하는 과정을 매 프레임마다 수행하게 되면 성능 하락이 생길 수 밖에 없다.<br>
따라서 로딩 시점에 메모리에 데이터를 올려두고 씬 전환 시점 같은 때에 데이터를 해제한다.<br>
즉, 게임이 실행되는 동안에는 데이터가 계속 메모리에 상주하게 된다.<br>
텍스쳐, 쉐이더 등 렌더링에 필요한 데이터 모두 GPU 메모리에 존재하고 있어야 한다.<br>
<br>
<br>

👉 **Render State와 DP Call**<br>
렌더링 루프를 돌면서 어떤 오브젝트를 렌더링해야하는 시점이 오면<br>
GPU에 어떤 텍스쳐, 버텍스, 쉐이더 등을 사용해야할지 전달해줘야하는데<br>
이런 정보들은 한 번의 명령으로 처리되는 것이 아니라 순서대로 일일히 알려줘야한다.<br>
그렇다고 하나씩 알려주는 것은 비효율적이니 GPU는 해당 정보를 담는 테이블을 가지고 있다.<br>
이런 테이블을 Render State (렌더 상태)라고 부른다.<br>
렌더 상태의 테이블 정보들은 GPU 메모리의 어느 곳에 필요한 데이터가 있는지 데이터의 주소를 저장해둔다.<br>

**CPU가 렌더 상태를 변경하는 명령을 보내면, GPU는 렌더 상태에다가 오브젝트를 그리기 위한 정보를 저장한다.**<br>

CPU는 명령을 보내고 마지막으로 **GPU 에게 메시를 그리라는 명령**을 보낸다.<br>
이 명령을 Draw Primitive Call, DP Call이라고 한다.<br>
**GPU는 DP Call을 받으면 받아두었던 렌더 상태의 정보들을 기반으로 메시를 렌더링한다.** ⭐<br>

메시를 렌더링하고 난 뒤, CPU는 이제 또 다른 오브젝트를 렌더링 하기 위해 상태 정보를 변경하는 명령을 보낸다.<br>
이 때 바뀔 필요가 없는 상태의 명령은 보내지 않는다.<br>
이렇게 렌더 상태를 변경해주고 마지막으로 GPU가 DP Call을 받으면<br>
또 바뀐 상태대로 렌더링을 하는 것이다.<br>
이런 방식으로 CPU는 필요한 정보를 갱신하는 렌더 상태 변경 명령을 보내고,<br>
GPU는 그대로 렌더 상태를 변경하고, CPU가 다시 DP Call을 주면 GPU가 렌더링하는 과정을 반복한다.<br>

단순히 그리라는 명령인 DP Call 뿐 아니라 넓은 의미로 상태 변경 명령부터<br>
DP Call까지를 모두 포함한 것을 드로우 콜이라고 한다.<br>

즉 **Draw Call = Render State Changes + DP Call(Draw Primitive Call)** ⭐ 이라는 것이다.<br>
<br>
<br>

👉 **Command Buffer**<br>
또 CPU가 GPU에게 명령을 보낸다고 표현했지만 사실 바로 명령을 주지 않고 중간에 한 단계를 거친다.<br>
**바로 명령을 보낸다면 GPU가 다른 작업을 수행하고 있다면 CPU가 명령을 주고 할일을 해야되기 때문에<br>
GPU가 하던일을 마칠 때까지 기다려야하는 불상사가 생길 것이다.**<br>
그래서 CPU는 **명령을 버퍼에 쌓아놓고, GPU는 버퍼에서 명령을 가져가서 할 일을 하는 방식으로 일한다.**<br>
이렇게 일을 쌓아두는 버퍼를 Command Buffer라과 부른다.<br>
커맨드 버퍼는 **FIFO**(First In First Out) 방식으로 명령을 처리한다.<br>
<br>
 
-> Vulkan과 Metal은 여러개의 커맨드 버퍼를 이용하여 멀티 쓰레드로 처리하기도 한다.<br>
-> 따라서 기존 OpenGL ES보다 드로우콜 부담이 적다.<br>
<br>
<br>

👉 **Draw Call은 CPU 바운드의 병목**<br>
문제는 **CPU가 명령한 것이 GPU에서 사용하는 신호로 변환되어야한다**는 것인데,<br>
이는 결국 CPU에게 **부담**이 된다.<br>

그래픽스 API들은 CPU에서 GPU로 보내는 명령을 공통적인 API로 구성한다.<br>
API가 호출되면 드라이버 칩셋에 알맞은 신호를 전달하여 **GPU에 맞게 명령을 변형하는 과정을 거친다.**<br>
이 과정을 거치기 때문에 CPU가 GPU에게 명령을 보낼 때 오버헤드가 발생한다.<br>
그래서 드로우콜은 CPU 바운더리의 오버헤드이다.<br>
<br>

**즉 드로우콜은 GPU의 성능보다 CPU의 성능에 의존적이라는 것을 알 수 있다.**<br>
이러한 드로우 콜로 인한 성능 하락을 막기 위해선 ⭐ **드로우 콜 횟수 자체를 줄여야한다.** ⭐<br>
<br>

-> Multithreaded Rendering, 멀티 쓰레드 렌더링<br>
**렌더링에 필요한 작업들을 별도의 쓰레드로 분리해서 렌더링 성능을 높이는 것.**<br>
즉 CPU의 부담을 줄여주는 것이다.

Edit > Project Settings > Player > Other Settings > Rendering 에서<br>
Multithreaded Rendering을 체크할 수 있다.<br>
다만 모든 디바이스에서 멀티쓰레디드 렌더링이 잘 돌아간다는 보장은 없다.<br>
CPU의 코어가 많지 않은 구형 디바이스는 잘 안돌아갈수있다.<br>
-> 타깃 디바이스에서 확인해봐야 한다.<br>
<br>
<br>

👉 **드로우 콜의 발생 조건**<br>
기본적으로 오브젝트를 하나 그릴 때 Mesh 1개, Material 1개라면 드로우콜이 한 번 발생한다.<br>
즉, Batch가 1이 된다.<br>

하지만 오브젝트 하나가 **메시** 여러개로 구성되어있는 경우... 메시가 17개라면 드로우콜도 17번 발생한다.<br>
이 메시들이 1개의 메테리얼을 공유하더라도 메시 개수 대로 17번의 드로우 콜이 필요하다.<br>
반대로 하나의 메시에 **메테리얼**이 여러 개여도 그 개수만큼의 드로우 콜이 필요하다.<br>

**쉐이더에 의해서도 드로우 콜이 늘어날 수 있다.** ⭐<br>
쉐이더 내에서는 **멀티 패스(Multi Pass)** 라고, 두 번 이상 렌더링을 거치는 경우가 존재한다.<br>
대표적인 예가 카툰 렌더링이다. 첫번째 패스에서 모델을 렌더링하고,<br>
두번째 패스에서 모델 외곽선을 그려준다.<br>
렌더링을 두 번 해야하므로 드로우 콜이 두 번, Batch도 두 번..<br>
**따라서 메시가 하나, 메테리얼이 하나라고해서 반드시 하나의 드로우 콜만 발생하는 것이 아니다.**<br>

특히 모바일의 경우 드로우콜 횟수가 크면 성능에 많은 영향을 끼칠 수 있으므로<br>
드로우 콜을 신경쓰면서 최대한 줄여야한다. **데스크톱에서는 1000개가 넘어도 가능하지만<br>
모바일에서는 100개도 많은 편이다.** 최신 모바일 디바이스는 200개가 넘는 것도 가능하지만<br>
디바이스 마다 다르므로 드로우 콜의 기준을 확정지을 수 없다.<br>

또 드로우콜을 개수로 따져왔지만, 사실 드로우콜 마다도 비용이 각각 다르다.<br>
**당연히 상태 변경이 많이 필요한 드로우 콜과 적게 필요한 드로우 콜은 비용 차이가 날 것이다.**<br>
<br>
<br>

👉 **Batch & SetPass**<br>
유니티에서는 드로우 콜을 **Batch와 SetPass 두 용어로 나누어 표시**한다.<br>
<br>

![배치및셋패스설명](https://user-images.githubusercontent.com/43705434/132845119-1a6e5b0d-f5ec-44e3-98a6-0b55470bfd3f.PNG)<br>
<br>

👉 **Batch**<br>
**DP Call과 Render State Change 들을 합친 넓은 의미의 드로우 콜.**<br>

만약 Batch가 10번, SetPass가 1번 발생했다면 10번의 드로우 콜 동안 쉐이더의 변경은 없었고,<br>
메시 및 트랜스 폼 정보 등 최소한의 상태 변경만 이뤄졌다는 것을 의미한다.<br>

SetPass도 10번 일어났나면 10번의 드로우 콜 마다 매번 쉐이더의 변경이 이뤄졌고,<br>
경우에 따라 **많은 상태 변경이 일어났다는 것을 의미한다.**<br>
당연히 이 경우가 성능을 더 많이 잡아먹을 것이다.<br>
<br>
<br>

👉 **SetPass Call**<br>
**SetPass는 메테리얼과 쉐이더에 관련된 것에 대한 배치를 말한다.**<br>
SetPass에서 알려주는 **상태 변경은 쉐이더의 변경 혹은 쉐이더 파라미터들의 변경**이 일어나는 경우다.<br>
씬 오브젝트를 렌더링하는 과정에서 **메테리얼이 바뀌면 ⭐ 그에 따라 쉐이더 및 파라미터들이 바뀌고**<br>
SetPass 카운트가 증가한다.<br>
**이 때 많은 상태 변경이 일어나야 하기 때문에 SetPass 횟수도 중요하다.**<br>

만약 게임이 CPU 바운드이고 GPU에 명령을 보내는 과정, 즉 드로우콜이 병목이라면<br>
**SetPass call 횟수를 줄이는게 가장 효율적이다.** ⭐<br>

서로 다른 메시를 사용한다고 SetPass call이 늘어나는 것은 아니다.<br>
⭐ **다른 메시라도 같은 메테리얼을 쓰면 늘어나지 않는다.** ⭐<br>

**10개의 오브젝트가 서로 다른 메시여도 같은 메테리얼을 쓴다면 Batch는 10번 발생해도<br>
SetPass는 1번만 발생한다.**<br>

**이렇게 SetPass call이 적으면 Batch 구성이 잘 되어있는 것이다.**<br>
이러한 이유 때문에 아틀라스를 활용하여 여러 오브젝트들을<br>
한 개의 Material로 묶어서 Set Pass Call을 줄이는 것이 중요하다.<br>
<br>
<br>

## 🔔 Draw Call Optimization 
아래 링크에 더 자세한 설명 - 필독<br>
https://mathmakeworld.tistory.com/61 <br>

👉 **Batching**<br>
배칭이란 드로우 콜을 줄이는 작업을 의미한다.<br>
유니티에서 배칭을 활용함으로써 드로우 콜을 많이 줄일 수 있기 때문에 거의 필수적으로 사용해야하는 기능이다.<br>
⭐ **여러 Batch를 묶어서 하나의 Batch로 만드는 것을 Batching이라고 한다.<br>
즉 Batching은 여러 번 드로우 콜 할 상황을 하나의 드로우 콜로 묶는 과정이다.** ⭐<br> 

다른 오브젝트, 메시를 사용하더라도 **메테리얼이 같다면 하나의 Batch로 구성할 수 있다.**<br>
여러 개의 다른 오브젝트들이지만 **메테리얼이 같다면⭐ 배칭처리를 통해 한 번에 그리는 것이 가능하다는 얘기다.**<br>

같은 텍스쳐, 같은 쉐이더를 이용한 메테리얼이더라도 따로 두개를 만들어 두면<br>
그 두 개는 다른 메테리얼로 인식, 즉 배칭이 되지 않는다.<br>
스크립트에서 메테리얼에 접근할 때도 이런 이유에서 조심해야할 것이 있다.<br> 

```c#
GetComponent<Renderer>().material.color = Color.red;
```
<br>

이렇게 메테리얼의 속성을 수정하면 메테리얼이 수정되는 것이 아니라 **메테리얼의 복사본이 생성된다.**<br>
대신 **Renderer.sharedMaterial로 수정하면 복사본이 생성되지 않고 공유된 메테리얼 원본을 수정한다.**<br>
공유하고 있던 **다른 친구들도 수정된 결과가 적용되니 인지**하고 유의해서 사용해야 한다.<br>
-> MaterialPropertyBlock를 이용하여 해결할 수 있다고 한다.<br>
-> ex) **피격받은 몬스터의 메터리얼 색상만 바꿔야하는데 피격당하지 않은 몬스터까지 바뀌는 경우를 방지**<br>

배칭을 하기 위해서는 **하나의 메테리얼을 여러 메시들이 공유해서 사용해야한다.<br>
즉 ⭐ 텍스쳐 하나를 공유해서 사용해야한다는 뜻이다.** ⭐<br>
**즉 파츠가 여러 개인 경우 메시는 각각 다르지만 하나의 머티리얼을 통해 색상을 입히는 것이다.<br>
이렇게 하기 위해서는 여러 장의 텍스처를 하나를 묶어 텍스처 아틀라스 기법으로<br>
하나의 텍스처로 여러 메시들이 사용할 수 있게 하는 것이다.**<br>
그래서 텍스쳐 하나에다가 여러 개의 텍스쳐를 합쳐서 사용하는 **텍스쳐 ⭐ 아틀라스** 기법으로 리소스가 제작된다.<br>

그러면 모든 메시의 텍스쳐를 하나로 합쳐버리면 안될까?<br>
안된다. 해상도 문제를 고려해야한다. 512 해상도의 텍스쳐 16개를 합치면 2048 해상도의 텍스쳐가 필요하다.<br>
구형 디바이스에서는 성능 저하가 발생할 수 있기 때문에 해상도를 고려하면서 작업해야한다.<br>
-> 또한 메모리도 고려해야 한다.<br>
<br>

Batching은 Static Batching, Dynamic Batching 두 종류가 있다.<br>
Edit > Project Settings > Player에서 Static Batching, Dynamic Batching을 체크할 수 있다.<br>
체크하면 조건에 맞는 경우 자동 배칭이 된다.<br>
간단하게 사용할 수 있지만 각 배칭 기법은 특성과 한계가 존재하니 알고 쓰도록 하자.<br>
<br>
<br>

👉 **Static Batching**<br>
**정적인 오브젝트를 위한 배칭 기법. 주로 배경 오브젝트들이 해당된다.** ⭐<br>
**동일한 재질을 공유하는 정적 오브젝트들(static objects)을 결합하여 하나의 메쉬로 만든다.<br>
오브젝트들은 공유된 지오메트리와 재질을 사용하기때문에 드로우콜 사이의 상태변경을 거의<br>
일으키지않으며 결과적으로 batches 및 드로우콜의 개수를 줄일수있다.** ⭐⭐⭐<br>

Static Batching을 적용할 오브젝트라면 인스펙터에서 Static을 체크해줘야 한다.<br>
이걸 켜주면 스태틱 배칭의 대상으로 인정받아 로딩타임에서 자동으로 배칭처리가 될 것이다.<br>
**당연히 다이나믹 배칭보다 효율적이다. ⭐ 런타임에서 수행할 버텍스 연산이 없기 때문이다.**<br>
**드로우콜 수를 줄이기 위해 오브젝트들을 합쳐 내부적으로 ⭐하나의 메시⭐로 만들어준다.**<br>

Stats 창에서 Saved by batching, 즉 배칭으로 얼마나 드로우 콜을 절약했는 지 확인할 수 있다.<br>

메테리얼이 1개라고 무조건 1개의 배치로 구성되는 건 아니고 라이트맵, 라이트프로브, 동적라이트 영향 여부 등<br>
다양한 조건에 의해서 배칭이 나뉠 수 있다.<br>
배칭이 왜 나뉘는지는 프레임 디버거로 확인할 수 있다.<br>

로딩타임에서 배칭처리를 하기 때문에 처음부터 씬에 존재해야 스태틱 배칭에 껴준다.<br>
**나중에 추가되는 정적인 오브젝트들은 자동으로 스태틱 배칭이 되지 않고**<br>

```c#
StaticBatchingUtility.Combine()
```
<br>

**로 런타임 상에 추가된 정적인 오브젝트들도 배칭처리를 받을 수 있게 해줘야한다.**<br>
But 스태틱 배칭에 껴주기 위해 **데이터를 수집하고 메시를 재생성** ⭐ 해야하기 때문에<br>
많은 시간이 필요하므로 되도록 자제하도록 하자.<br>
<br>

**주의할 점**<br>
**메모리가 추가로 필요하다!**<br>
다른 메시들을 메테리얼이 같다는 이유로 한 번에 그리는 것이다.<br>
따라서 배칭처리를 하면 오브젝트들을 합쳐서 **내부적으로 하나의 메시로 만들어 놓는데,**<br>
여러 개의 메시를 합친, **거대한 메시를 만들기 위한 추가 메모리가 필요한 것이다.**<br>
이렇게 새로 만들어낸 메시를 GPU가 가져가서 그대로 화면에 렌더링하므로 드로우 콜은 1번에 처리될 수 있던 것이다.<br>
**추가적으로 메모리를 희생하더라도 드로우 콜을 줄일 수 있기 때문에 런타임 성능을 높일 수 있다.** ⭐<br>
-> **숲에 존재하는 모든 나무들을 하나의 메시로 묶어버린다면 과도한 메모리 영역을 차지하게 될 것이다.**<br>
-> 따라서 맹목적으로 사용하면 안된다.<br>

**스태틱 배칭 처리로 하나의 큰 메쉬를 사용하지만, 그래도 개별적으로 컬링처리는 여전히 된다.**⭐⭐<br>
<br>
 
-> **배경 맵 모듈화** ⭐<br>
씬을 하나의 커다란 메시로 만드는 것 보다 **모듈화해서 조립하듯이 제작하는 것이 성능면에서 더 좋다.**<br>
**하나의 커다란 메시로 만든다면 메시 일부만 보여도 전체 메시의 폴리곤을 처리하기 때문이다.**<br>
**스태틱 배칭 처리가 되더라도 원래의 게임오브젝트 기준으로 컬링이 이뤄진다.** ⭐⭐<br>
근데 야외 맵은 한 화면에 배경 오브젝트가 그렇게 많지않고 반복되는 모듈이 적어서 조금 애매하다.<br>
또 모듈의 단위를 너무 작게나누면 오히려 비효율적이다.<br>
<br>

**고찰**<br>
<br>
 - Q : 드로우콜이 이렇게 중요하다면, 모든 배경을 하나로 합쳐서 내보내는게 제일 좋은것인가?<br>
 - A : **아니다. 하나의 메쉬라면 화면에 배경중 극히 일부분만이 보일 경우에도 전체를 무조건 그리게 된다.<br> 
        하지만 모듈화를 했을 경우에는 프러스텀 컬링과 오클루전 컬링을 통해 일부 메쉬를 그리지 않는다.<br>
        그렇다고 굉장히 세분화해서 나누면 합치는 과정에 코스트가 든다. 적정한 선에서 시야각에 들어오는<br> 
        구역별로 나누는 것이 중요하다.** ⭐⭐⭐<br>
<br>

-> **위에서 배경을 모듈화하라는 것은 외부 그래픽 툴에서 전부 합쳐서<br>
하나의 오브젝트로 유니티에 가져오지 말라는 의미같다.<br>
그래픽 툴에서 하나로 합쳐서 보내버리면 유니티에서 컬링을 할 수 없기 때문.** ⭐<br>
<br>

👉 **Dynamic Batching**<br>
Static과 반대로, Static이 체크되지 않은 **동적인 오브젝트들 중<br>
동일한 메테리얼을 사용하고 특정 조건을 만족하는 오브젝트들을 대상으로<br>
배칭처리를 하는 기능이다.**<br>
역시 Dynamic Batching을 체크해주면 별도의 추가 작업없이 동작한다.<br>
하지만 **런타임시에 ⭐ 배칭처리를 해야되기 때문에 제약사항이 많다.**<br>
정적 배칭에 비해서 조건도 까다롭고 눈에띄는 효율이 아니므로 사실 크게 신경쓰지 않아도 되는 부분이다.<br>

매 프레임 씬에서 동적인 오브젝트들의 버텍스를 모아서 합쳐주는 과정을 거친다.<br>
모은 버텍스들을 다이나믹 배칭에 쓰이는 버텍스 버퍼와 인덱스 버퍼에 담으면<br>
GPU가 이것을 가져가서 렌더링한다.<br>
**결과적으로 매번 데이터 구축과 갱신이 발생하기 때문에 매 프레임마다 오버헤드가 발생한다.** ⭐<br>
일반적으로 렌더링 할 때는 버텍스 쉐이더에서 월드 스페이스로 변환하는 과정이<br>
GPU에서 고속연산으로 이뤄지는데, 다이나믹 배칭을 위해서는 오브젝트의 버텍스를<br>
월드스페이스로 변환하는 **연산이 CPU에서** 이뤄진다.<br>
**따라서 이 연산과정이 드로우 콜보다 시간이 오래걸리면 오히려 효율이 떨어지는 것이다.<br>
배칭 오버헤드와 드로우 콜 시간을 비교하여 더 빠른 쪽으로 하는 것이 맞다.** ⭐⭐<br>

만약 특정 오브젝트의 배칭 오버헤드가 더 커서 배칭을 쓰지 않도록 하고 싶다면<br>
쉐이더 태그에서 DisableBatching 플래그를 True로 설정해주면 된다.<br>
아래는 쉐이더 코드에서 쉐이더 태그를 다는 예시.<br>

```c#
SubShader {
	Tags { "RenderType" = "Opaque" "DisableBatching" = "True" }
    ...
```
<br>

**제약 사항**<br>
오버헤드가 발생하므로 제약 사항이 많다. 그래서 스태틱 배칭보다 잘 쓰이지 않는다.<br>

1. Skinned Mesh 적용 불가.<br>
움직이는 캐릭터 Skinned Mesh, GPU나 SIMD에서 고속연산 수행하기 때문에<br>
다이나믹 배칭으로 묶으면 CPU 효율이 떨어짐.<br>

2. 버텍스가 너무 많은 메시는 다이나믹 배칭에서 제외.<br>
너무 많은 버텍스를 수집하면 오버헤드가 드로우콜보다 높아져서 제외됨.<br>
포지션, 노말, UV를 사용하는 모델이라면 300 이하의 버텍스를 가진 모델만 다이나믹 배칭 적용 가능.<br>
(모바일게임에서도 300은 보통 넘기 때문에 대부분 적용이 어려움)<br>
<br>
<br>

👉 **Skinning, 스키닝**<br>
**메시를 애니메이션 포즈에 맞게 메시의 버텍스들을 보정해주면서 변형해주는 과정.** ⭐<br>
**애니메이션을 가진 모델들은 스키닝이 필요하므로 Skinned Mesh Renderer라는**<br>
특별한 메시 렌더러를 컴포넌트로 가진다.<br>

렌더링 전에 스키닝 연산이 이뤄지면서 버텍스 위치의 재계산이 일어난다.<br>
따라서 스키닝 되는 메시의 폴리곤이 많을수록 렌더링도, 스키닝 연산도 부담이 생긴다.<br>
스키닝 연산은 CPU에서 이뤄지므로 결과적으로 버텍스가 많은 스키닝 메시는 스키닝 처리에서<br>
CPU의 부담을 유발할 수 있다.<br>
GPU를 통해 연산하고 싶다면 Edit > Project Settings > Player > Other Settings > GPU Skinning을<br>
체크하면 된다. GPU가 더 빨라보이지만, CPU 스키닝 연산은 SIMD(Single Instruction Multiple Data)라는<br>
아키텍처를 통해 고속연산이 가능하기 때문에 CPU, GPU 중 어디에 병목이 있는지 확인하고<br>
병목이 없는 쪽에서 스키닝을 연산해서 병목이 있는 바운드의 부담을 덜어주는 것이 좋을 것이다.<br>
**대부분 게임은 GPU 자원이 많이 필요하므로 CPU에서 스키닝 연산을 하는 편이다.**<br>
<br>
<br>
                               
👉 **2D Sprite Batching**<br>
위에서 잠깐 언급했듯이, **2D Sprite도 Batching이 이뤄질 수 있다.**<br>
3D 보다 버텍스가 적기 때문에 배칭이 훨씬 효율적으로 가능하다.<br>
Static이나 Dynamic Batching처럼 체크하지 않아도 자동으로 배칭이 이뤄진다.<br>

![아틀라스](https://user-images.githubusercontent.com/43705434/132845110-847afe69-4d36-43dd-9ee9-7c5aed89f48e.PNG)<br>
<br>

**텍스처 아틀라스와 같은 기법**으로 스프라이트들을 하나의 이미지에 모아 넣는<br>
**스프라이트 시트(Sprite Atlas)** 로 많이 제작된다.<br>
-> 스프라이트 시트가 텍스처 아틀라스와 다른점은 애니메이션에 좀 더 사용된다는 점?..<br>
<br>
<br>

👉 **GPU Instancing**<br>
Static, Dynamic Batching 외에도 GPU Instancing이라는 기법을 활용해서 드로우 콜을 줄일 수 있다.<br>
인스턴싱이란 동일한 메시의 복사본을 만드는 것이다. 한번의 드로우 콜로 오브젝트의 여러 복사본을<br>
렌더링한다는 점은 배칭과 같다. 인스턴싱은 배칭에 비해 런타임 오버헤드가 적다.<br>
배칭은 CPU에서 지오메트리 정보들을 연산해 합친 메시를 새로 만들어내는 과정을 거치고<br>
GPU가 이를 가져다 렌더링하는 방식이었는데, **GPU 인스턴싱은 메시를 새로 만들어 내지 않고<br>
인스턴싱 되는 오브젝트들의 트랜스폼 정보를 별도의 버퍼에 담는다.<br>
GPU는 이 버퍼와 원본 메시를 가져다 여러 오브젝트들을 한번에 처리해서 렌더링한다.**<br>
인스턴싱 처리를 **GPU에서 처리하기 때문에 GPU에서 메시를 재구성하는 오버헤드나 메모리 이슈로부터 자유롭다.**<br>
**오버헤드로 인한 제약이 적어서 원본 메시의 버텍스 개수와 상관없이 런타임에서<br>
동적인 오브젝트들을 배칭처리할 수 있다. 다이나믹 배칭보다 ⭐ 제약이 적고 부담도 없다.**<br>

Standard Shader를 쓰는 메테리얼의 파라미터 중 Enable GPU Instancing을 체크하면<br>
이 메테리얼을 쓰는 오브젝트들은 유니티가 자동으로 인스턴싱 처리를 해준다.<br>
**동일한 메시끼리만 ⭐ 한 번의 드로우콜로 처리가 가능하다.<br>
-> 즉 똑같은 오브젝트들을 한번에 그려줌으로써, 드로우 콜을 줄여주는 기능이라는 것이다.** ⭐<br>

**역시 Skinned Mesh Renderer를 쓰는 스키닝 메시에는 사용할 수 없다.**<br>
GPU에서 처리하는 것이므로 디바이스의 스펙에 의존적이다. 지원하는 디바이스에서만 사용할 수 있다.<br>
<br>
<br>

👉 **Frame Debugger**<br>
드로우 콜은 Stat 창이나 Profiler로 확인할 수 있었지만 상세하게는 알 수 없었다.<br>
그럴 때 프레임 디버거를 쓴다.<br>

프레임이 어떻게 렌더링되는지 직관적으로 확인할 수 있다.<br>
게임 수행 중 프레임을 캡쳐해서 드로우콜을 순서대로 확인할 수 있고,<br>
각 드로우콜 과정에서 어떤 메시가 렌더링되고 쉐이더의 속성은 무엇인지도 확인할 수 있다.<br>
배칭 처리 중에 드로우콜이 나뉜다면 왜 나뉘는지도 확인할 수 있다.<br>
<br>
<br>

👉 **컬링 (Culling)**<br>
**드로우 콜을 줄이기 위해선 렌더링할 오브젝트 수를 줄이는게 중요하다.<br>
컬링은 현재 카메라에 보이는 것만 렌더링 할 수 있도록 하는 것이다.** ⭐<br>
<br>

👉 **프러스텀 컬링 (Frustum Culling)**<br>
절두체 컬링은 카메라에 잡히지 않는, **즉 카메라 밖에 있는 오브젝트는 ⭐ 그리지 않는 것이다.**<br>
절두체 컬링의 설정은 카메라 컴포넌트에서 계산 할수 있으며<br>
**기본적인 컬링이므로 컬링 자체를 설정할 필요는 없다.**<br>
-> **즉 유니티에서 자동으로 수행**<br>
**Camera의 Clipping Planes값을 이용해 레이어 별로 컬링 거리를 설정 할 수 있다.** ⭐<br>
-> **Fog 기법**을 같이 사용해주어야 자연스럽게 보이게 된다.<br>
<br>

👉 **후면 컬링**<br>
**후면컬링은 뒷면을 그리지 않는 것**을 이야기하는데, 이는 정점의 그리기 순서로 결정할수 있다.<br>
예를들어 정점 순서가 1->2->3으로 그릴수 있지만 뒤집혔을때 3-> 2->1 순서가 되면 그리지 않는 것<br>
<br>

👉 **오클루전 컬링 (Occlusion Culling)**<br>
**오클루젼 컬링 (Occlusion Culling)은 오브젝트가 다른 오브젝트에 의해 가려져서<br>
카메라에 보이지 않을 때 해당 오브젝트의 랜더링을 비활성화 하는 기능이다.** ⭐<br>
3D 그래픽에서는 카메라에서 가장 먼 오브젝트가 먼저 그려지고 가까운 오브젝트는<br>
그 위에 그려지므로(일면 덮어 그리기("overdraw")), 이 기능이 자동으로 수행 되지는 않는다.<br>
-> 직접 설정하여 기능을 동작하도록 해줘야 한다.<br>
<br>
<br>

👉 **LOD (Level of Detail)**<br>
**카메라로부터 멀리 떨어져 화면내 차지 비율이 낮으면 디테일을 낮추는 기능이다.**<br>
LOD는 보통 **정적 LOD와 동적 LOD로 나뉘는데** 지형물에는 대부분 동적LOD가 사용되고<br>
원래는 캐릭터에 정적 LOD방식을 많이사용했지만 GPU기능의 발달로<br>
캐릭터에도 동적 LOD를 쓰는 추세라고 한다.<br>
<br>

👉 **정적 LOD**<br>
정적 LOD는 카메라와 물체의 거리에따라서 가까운 거리에있는 물체는 정밀한 메쉬를 쓰고<br>
멀리있는 물체는 상대적으로 낮은 단계로 쓰는방식이다.<br>
-> **즉 단계 별 메쉬를 준비해두어야 한다.** ⭐<br>
이 방식은 연산이 간단하여 속도가 빠르지만 **여러 단계의 메쉬를 갖고있어 메모리**가 낭비되며<br>
거리에 따라서 메쉬의 단계가 급격하게 변해 **popping 현상**이 자주 일어난다.<br>

**popping 현상: LOD단계가 변할 때, 갑작스럽게 모양이 바뀌며 그래픽이 튀는 현상을 가리킨다.**<br>
-> 정적 LOD 사용 시 급격한 레벨의 차이로 다른 레벨 사이에 구멍이 뚫리는 것과 같은 현상이다.<br>
-> 사라지는 버텍스의 위치값을 레벨차이에 의한 보간값으로 해결할 수 있다고 한다.<br>
<br>
<br>

👉 **동적 LOD**<br>
동적 LOD는 거리에 따라서 **실시간으로 메쉬의 정밀도를 변화시키는 것이다.**<br>
이 방식의 장점은 런타임에 정밀도가 바뀌는 방식이기 때문에 메모리의 낭비가적다.<br>
**하지만 메쉬 분할이나 간략화에 따른 추가적인 연산이 많이 필요해서 렌더링속도가 상대적으로 느리다.** ⭐<br>
<br>
<br>

**라이트맵으로도 드로우 콜을 줄일 수 있다.**<br>
<br>
<br>

## 🔔 참조링크
https://metamon9.tistory.com/6<br>
https://mentum.tistory.com/53<br>
https://wonsorang.tistory.com/493 <br>
https://daniel9811.tistory.com/18 (LOD) <br>
<br>
<br>
