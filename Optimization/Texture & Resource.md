## 🔔 Texture
게임의 리소스중 대부분은 텍스처이다. 따라서 텍스처 최적화는 게임 성능에 가장 큰 영향을 미친다.<br>
아래는 텍스처 최적화에서 자주 논의되는 개념들을 나열한 것이다.<br>
<br>

👉 **POT**<br> 
POT(팟)은 Power Of Two 의 약어로, **2의 거듭제곱을 말한다.**<br>
많은 플랫폼에서 2의 거듭제곱 크기인 텍스처만을 사용할 수 있다.<br>
하지만 게임에서는 2의 거듭제곱이 아닌 텍스처들도 분명 존재하고,<br>
유니티는 이를 사용할 수 있도록 하기 위해 내부적으로 작업을 수행한다.<br>
**이 작업은 원본 텍스처보다 큰 2의 거듭제곱 텍스처를 만들고 원본 크기만큼을 복사, uv 를 조절하는 작업이다.**<br>
ex) **900 x 900 텍스쳐는 1024 x 1024로 변환되어 메모리에 로드된다.** ⭐<br>

-> ⭐ **따라서 메모리 비용이 증가하며, 원본 크기를 제외한 영역은 재활용할 수 없으므로 낭비이다.<br>
따라서 가능한 2의 거듭제곱 텍스처를 사용해야만 한다.** ⭐<br>
<br>

만약 POT가 불가능한 경우라면 **Atlas(POT)로 패킹해서 사용하도록 하자.** ⭐<br>
-> 이 말은 Atlas 내에 존재하는 이미지들은 POT를 준수하지 않아도 된다는 소리다.<br>
-> 어차피 메모리에는 Atlas가 로드되기에, Atlas 이미지만 POT이면 되기 때문이다.<br>
<br>

애초에 텍스쳐를 POT으로 만들어야 하는 이유에 대해서 찾아보니 여러 답변을 들을 수 있었는데<br>
압축 시 손실율을 줄이기 위해.. 혹은 HW가 애초에 POT 형식만을 처리할 수 있다는 등..<br>
https://gamedev.stackexchange.com/questions/26187/why-are-textures-always-square-powers-of-two-what-if-they-arent<br>
**해당 링크에 정확한 답이 나와있었다. 간략히 말하자면 예전 그래픽카드의 데이터 처리 방식이<br>
POT 및 정사각형을 고수했기 때문이라고 한다. 현재 보급되는 HW들은 non-POT도 처리할 수 있지만<br>
호환성 및 메모리의 낭비를 줄이고자 최대한 POT크기, 정사각형의 텍스쳐를 사용하는 것이라고 한다.**<br>
<br>
<br>

👉 **Compression**<br>
1024 x 1024 크기의 32비트 텍스처는 4MB의 메모리를 차지한다.<br>
안드로이드를 기준으로, 이 텍스처를 ETC1 포맷으로 압축하면 512KB 로 정확히 8배 감소한다.<br>
**메모리 최적화 면에서 압축이 가장 높은 효율을 보인다.** ⭐<br>
하지만 압축에는 다음과 같은 제약사항이 있다.<br>

**제약 사항** ⭐<br>
- 대부분 **POT 크기의 텍스처만 지원한다.**<br>
- iOS 에서 사용하는 압축 방식인 PVRTC 같이 **정방 크기**의 텍스처만 지원하는 **경우도 있다.**<br>
- 알파를 지원하지 않는 경우도 있다. ETC1 같은 포맷은 지원하지 않는다.<br>
<br>

압축은 대부분의 하드웨어에서 지원하고 원본과 비교했을 때<br>
품질 저하가 적기 때문에 적극 권장되는 방법이다.<br>
**이미지 메모리 사용량을 잘 관리하는 방법은 눈에 보이는 이미지는 압축하지 않고,<br>
잘 보이지 않는 이미지는 압축을 많이 하는 것이다.**<br>

특히나 유저 인터페이스의 경우에는 압축을 많이 하면 이미지가 깨지기 때문에<br>
게임의 퀄리티가 상당히 낮아 보인다. 이런 이유로 **유저 인터페이스는 압축을 피하는 것이 좋다.**<br>
하지만 3D 몬스터 캐릭터의 텍스쳐 등은 조금 압축을 하더라도 퀄리티에 크게 영향을 주지 않는다.<br>
스마트폰 게임 특성상 제한된 리소스를 효율적으로 써야 하기에 **퀄리티를 강조하고 싶은 영역에만**<br>
보다 화질 좋은 텍스쳐를 쓰는 것이 현명한 선택이라 할 수 있다.<br>
<br>

**추가  Tip.**<br>
1. 모바일, PC와 같은 플랫폼의 종류 또한 기기의 종류에 따라 ⭐ **지원하는 압축 포맷** 이 존재하기 때문에<br>
타겟 플랫폼을 제대로 확인하고 압축해 배포해야 한다.<br>

2. **알파 채널이 필요하지 않다면,** 압축 할 때 알파 채널이 없는 항목으로 선택하면<br>
RGB로만 압축하기에 메모리와 손실율을 지킬 수 있다.<br>
<br>
<br>

👉 **Color Channel Bits 낮추기**<br>
압축 포맷을 사용하지 않을 경우 RGBA 32비트 혹은 RGB 24비트 포맷이 많이 사용된다.<br>
둘의 차이는 알파 채널의 존재 여부이다. 각 채널당 8비트 를 할당한 포맷으로 품질면에서<br>
제일 좋은 반면 메모리는 가장 많이 차지한다. 채널에 할당되는 비트수를 낮추는 것으로<br>
품질은 떨어뜨리면서 차지하는 메모리를 낮출 수 있다.<br>
**RGBA 32비트, RGB 24비트 모두 16비트로 낮출 수 있는데 RGBA 32비트의 경우 각 채널당 4비트,<br>
RGBA 24비트의 경우 R채널은 5비트, G채널은 6비트, B채널은 5비트가 된다.**<br>
그라데이션같이 색의 분포가 넓은 경우 비트를 낮췄을 때 디더링( Dithering ) 현상이 심하게 나타나는데<br>
이를 줄이기 위해 포토샵 필터 등의 외부 툴이 필요한 경우도 있다.<br>
<br>

**비트를 낮추는 방법은 품질을 크게 떨어뜨리므로 주의해서 적용해야 한다.** ⭐<br>
<br>
<br>

👉 **Mipmap**<br>
텍스쳐에서 밉맵이란 텍스쳐에게 있어서 LOD같은 개념이다.<br>
만일 256x256짜리 텍스쳐가 화면에 그려진다고 생각을 해보자.<br>
이 텍스쳐가 화면에 굉장히 작은 영역으로 그려져서 실제로는 32x32픽셀만큼의<br>
영역만 그려지는 상황이라면 굳이 256 텍스쳐를 적용할 필요가 없다.<br>
괜히 대역폭을 낭비할 필요 없이 32 텍스쳐를 적용해도 충분한 상황일 것이다.<br>

![밉맵1](https://user-images.githubusercontent.com/43705434/133607317-85147247-c7b7-4da1-b508-80349103c352.PNG)<br>
<br>

**이런 컨셉이 바로 텍스쳐 밉맵이다.<br>
텍스쳐 하나 만들면 내부적으로는 여러 크기 단계의 텍스쳐를 만들어 두는 것이다.<br>
예를 들어서 256텍스쳐를 사용하면 내부적으로는 256,128,64,32,16,8,4,2크기의<br>
텍스쳐를 추가적으로 생성하게 되는 것이다.<br>
그러고서는 런타임에서 렌더링 시 픽셀쉐이더에서 텍스쳐를 읽어들일 때<br>
상황에 맞는 크기의 텍스쳐를 가져가 실시간 대역폭을 절약하는 것이다.** ⭐⭐⭐<br> 
<br>

**추가 Tip.**<br>
1. 밉맵을 사용하면 통상 30% 메모리를 더 먹기 때문에 필요치 않은 경우 밉맵을 꺼서 메모리를 아낄 수 있다.<br>
또한 밉맵 텍스처들은 빌드에 포함되므로 비활성화시 파일 크기가 줄어드는 것도 확인할 수 있다.<br>

2. 3D 게임에서는 특수한 상황이 아니고서는 밉맵을 끄는 것을 권장하지는 않는다.<br>
성능 문제도 있거니와 지글거림⭐이 발생하여서 시각적인 문제도 발생한다.<br>

![밉맵2](https://user-images.githubusercontent.com/43705434/133607319-e1e348db-2b05-433f-9622-1b7a994d4aef.PNG)<br>
<br>
<br>
<br>

👉 **Sliced Image 사용하기**<br>
사실 UI 리소스의 경우에는 특별한 이미지가 많이 사용된다기 보다는<br>
사용되는 이미지가 반복되어서 사용되는 경우가 많다.<br>
UI를 묶어주는 패널(Pannel), 입력을 받는 인풋 필드(Input Field), 버튼(Button) 등이 여기에 속한다.<br>

이런 것에 사용되는 리소스는 재사용성을 높여야 되지만, 초보 개발자나 초보 UI 디자이너는<br>
예쁘거나 멋지게 만들어야 되는다는 집착에 빠지거나, 최적화에 대한 신경을 못쓰고 만들어서,<br>
패널이나 버튼에 들어갈 이미지를 크기에 맞춰서 필요한 모든 사이즈 별로 만드는 경우가 종종 있다.<br>
<br>

![슬라이스1](https://user-images.githubusercontent.com/43705434/133607306-b60eda48-9f58-4712-b931-defc00a2c6bc.PNG)<br>
<br>

예를 들어 760x960 크기의 UI가 필요해서 거기에 해당하는 리소스를 만들어 냈다고 해보자.<br>
이걸 게임에 그대로 적용해버리면 패널을 꾸미기에 따라서는 UI가 예뻐보일 수는 있을 것이다.<br>
하지만 압축된 리소스임에도 불구하고 0.7MB라는 엄청난 용량을 자랑하는 것을 볼 수 있다.<br>
이게 겨우 하나여서 0.7MB지, 여러 종류의 많은 UI를 띄워야 하는 게임이어서 해당 UI의 크기 별로<br>
패널 리소스를 새로 만들어서 적용한다면 그리고 그 와중에 몇몇 리소스가 압축되지 않는 불상사가 발생한다면<br>
게임의 용량이나 메모리 소모는 엄청난 수준이 될 것이다.<br>
<br>

버튼이나 패널 같은 UI의 리소스의 경우에는 일반적으로 리소스의 모서리 부분을 제외한<br>
중심 부분은 반복되는 경우가 많다. 슬라이스드 이미지란 바로 이 점에서 착안한 아이디어로<br>
모서리 부분과 반복될 중심 부분 조금만 있으면 유니티 엔진이 중심 부분을 자동으로 채워주는 기능이다.<br>
그렇기 때문에 패널 리소스 중에서도 모서리 부분과 반복될 중심 부분 약간 만으로 리소스를 만들면<br>
위 이미지와 같은 커다란 패널 UI 리소스는 아래 이미지와 같이 아주 작게 줄일 수 있다.<br>
<br>

![슬라이스2](https://user-images.githubusercontent.com/43705434/133607310-4fe2b7c7-94eb-451c-84e9-cd7ca056c1ba.PNG)<br>
<br>
  
불필요한 중심 부분을 제거하는 것만으로도 이미지의 크기와 용량이 700분의 1로 줄어들었다.<br>
<br>

![슬라이스3](https://user-images.githubusercontent.com/43705434/133607314-7992f675-e8b9-4093-9377-722250159b65.PNG)<br>
<br>

리소스의 중심 부분을 제거한 뒤에는 유니티의 스프라이트 에디터(Sprite Editor)에서<br>
원형을 유지할 부분과 크기가 늘어났을 때 자동으로 채워질 부분을 설정해주면된다.<br>
위의 그림처럼 설정하면 UI의 크기가 늘어났을 때 모서리 부분은 원형을 유지하고<br>
가운데 십자 부분만 자동으로 채워지는데 씬에서 UI Image를 추가할 때,<br>
Image Type를 Sliced로 변경해주면 작은 이미지가 전혀 확대되거나<br>
이상한 모양으로 늘어지지 않음을 확인할 수 있다.<br>
<br>
<br>

👉 **Texture Filtering 추후 업데이트..**<br>
<br>
<br>

## 🔔 그 외 리소스 최적화
오디오, 메쉬 등등 최적화는 아래 링크를 직접 참고.<br>
https://loadofprogrammer.tistory.com/148 <br>
https://mentum.tistory.com/55 <br>
<br>
<br>

## 🔔 참조링크
https://cacodemon.tistory.com/entry/%ED%85%8D%EC%8A%A4%EC%B2%98-%EC%B5%9C%EC%A0%81%ED%99%94 <br>
https://tech.lonpeach.com/2017/02/19/unity3d-optimizing-performance/ <br>
https://ijemin.com/blog/%EC%9C%A0%EB%8B%88%ED%8B%B0-2d-%EA%B2%8C%EC%9E%84-%EB%B9%8C%EB%93%9C-%EC%B5%9C%EC%A0%81%ED%99%94-%ED%8C%81/ <br>
https://wergia.tistory.com/113 <br>
